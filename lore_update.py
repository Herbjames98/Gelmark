
import os, ast, json, time
from typing import Dict, Any, List

SCRIPT_DIR = os.path.dirname(__file__)
LORE_DIR = os.path.join(SCRIPT_DIR, "lore_modules")

def _act_key_from_scene_id(scene_id: str) -> str:
    if scene_id.startswith("prologue"): return "prologue"
    if scene_id.startswith("act1"): return "act1"
    if scene_id.startswith("act2"): return "act2"
    if scene_id.startswith("act3"): return "act3"
    # default to current prologue if unknown
    return "prologue"

def _file_for_act(act_key: str) -> str:
    return os.path.join(LORE_DIR, f"{act_key}.py")

def _load_lore_module_dict(act_key: str) -> Dict[str, Any]:
    """Parse the lore python file and return the assigned dict for <act_key>_lore."""
    path = _file_for_act(act_key)
    if not os.path.exists(path):
        # build a clean skeleton
        base = {
            "summary": "To be generated by AI.",
            "major_events": [],
            "companions_bond_status": [],
            "traits_unlocked": [],
            "shrines_visited": [],
            "visions_echo_sequences": [],
            "lore_codex_expansions": [],
            "timeline_edits": [],
            "key_terms_introduced": [],
            "locations_realms_visited": [],
            "faction_threat_encounters": [],
            "oaths_rituals_performed": [],
            "artifacts_discovered": [],
            "narrative_threads_opened": [],
            "narrative_threads_closed": []
        }
        return base
    with open(path, "r", encoding="utf-8") as f:
        src = f.read()
    try:
        mod = ast.parse(src)
        # find assignment to <act_key>_lore
        target_name = f"{act_key}_lore"
        for node in mod.body:
            if isinstance(node, ast.Assign):
                if len(node.targets) == 1 and isinstance(node.targets[0], ast.Name) and node.targets[0].id == target_name:
                    # Evaluate safely by compiling an expression from the value
                    code_obj = compile(ast.Expression(node.value), filename="<ast>", mode="eval")
                    val = eval(code_obj, {})  # dict literal expected
                    if isinstance(val, dict):
                        return val
    except Exception:
        pass
    # fallback empty if parse failure
    return {"summary": "To be generated by AI.", "major_events": []}

def _write_lore_module_dict(act_key: str, data: Dict[str, Any]) -> None:
    """Write back to <act_key>.py with a stable structure."""
    path = _file_for_act(act_key)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    # Ensure required keys exist
    defk = {
        "summary": "To be generated by AI.",
        "major_events": [],
        "companions_bond_status": [],
        "traits_unlocked": [],
        "shrines_visited": [],
        "visions_echo_sequences": [],
        "lore_codex_expansions": [],
        "timeline_edits": [],
        "key_terms_introduced": [],
        "locations_realms_visited": [],
        "faction_threat_encounters": [],
        "oaths_rituals_performed": [],
        "artifacts_discovered": [],
        "narrative_threads_opened": [],
        "narrative_threads_closed": []
    }
    for k,v in defk.items():
        data.setdefault(k, type(v)())
        if k == "summary" and not data.get("summary"):
            data["summary"] = defk["summary"]

    # Build python text
    import json as _json
    # Pretty print lists but keep a python dict literal
    def _py(obj):
        if isinstance(obj, str):
            return repr(obj)
        return _json.dumps(obj, indent=4, ensure_ascii=False)
    body = "        " + ",\n        ".join([f"{repr(k)}: {_py(v)}" for k,v in data.items()])
    text = f"# --- File: {act_key}.py ---\n# Auto-updated by lore_update\n\n{act_key}_lore = {{\n{body}\n}}\n"
    with open(path, "w", encoding="utf-8") as f:
        f.write(text)

def _summarize_scene(prev_title: str, choice_label: str, result_title: str, result_text: str) -> str:
    # Simple one-liner summary
    base = result_text.strip().split("\n", 1)[0]
    if len(base) > 160:
        base = base[:157] + "..."
    return f"{result_title} — Chose: {choice_label}. {base}"

def update_lore_from_scene(scene_snapshot: Dict[str, Any], choice: Dict[str, Any], generated_scene: Dict[str, Any]) -> None:
    """Append a concise event + trait/item/companion markers to the appropriate act lore file."""
    try:
        result_id = generated_scene.get("id", "") or ""
        act_key = _act_key_from_scene_id(result_id)
        lore = _load_lore_module_dict(act_key)
        # 1) Event summary
        prev_title = scene_snapshot.get("title","")
        choice_label = choice.get("label","")
        result_title = generated_scene.get("title", result_id)
        result_text = generated_scene.get("text","")
        ev = _summarize_scene(prev_title, choice_label, result_title, result_text)
        lore.setdefault("major_events", [])
        if ev not in lore["major_events"]:
            lore["major_events"].append(ev)
        # 2) Effects anchors
        eff = choice.get("effects", {}) or {}
        # traits
        for t in eff.get("traits_add") or []:
            name = t.get("name") if isinstance(t, dict) else str(t)
            if name:
                lore.setdefault("traits_unlocked", [])
                if all((isinstance(x, dict) and x.get("name") != name) for x in lore["traits_unlocked"]):
                    lore["traits_unlocked"].append({"name": name, "discovered_in": result_title})
        # artifacts/key items
        for a in eff.get("artifacts_add") or []:
            lore.setdefault("artifacts_discovered", [])
            if a not in [x.get("name", x) if isinstance(x, dict) else x for x in lore["artifacts_discovered"]]:
                lore["artifacts_discovered"].append({"name": a, "description": "", "location": result_title})
        for k in eff.get("key_items_add") or []:
            lore.setdefault("lore_codex_expansions", [])
            if k not in [x.get("title","") for x in lore["lore_codex_expansions"]]:
                lore["lore_codex_expansions"].append({"title": k, "content": "", "discovered_in": result_title})
        # companions
        for c in eff.get("companions_add") or []:
            cname = c.get("name", c) if isinstance(c, dict) else str(c)
            lore.setdefault("companions_bond_status", [])
            if all((isinstance(x, dict) and x.get("name") != cname) for x in lore["companions_bond_status"]):
                lore["companions_bond_status"].append({"name": cname, "status": "Ally", "event": f"Joined during {result_title}"})
        _write_lore_module_dict(act_key, lore)
    except Exception as e:
        # Silent fail: lore updates must not break gameplay
        pass

def backfill_lore_if_empty(live_state: Dict[str, Any]) -> None:
    """If an act's lore is empty, build a basic event list from story_log so the browser isn't blank."""
    log = live_state.get("story_log") or []
    if not log: return
    # Group entries by act based on result_scene_id prefix
    buckets = {"prologue": [], "act1": [], "act2": [], "act3": []}
    for e in log:
        rid = e.get("result_scene_id") or e.get("scene_id","")
        k = _act_key_from_scene_id(rid or e.get("scene_id",""))
        buckets.setdefault(k, []).append(e)
    for k, entries in buckets.items():
        if not entries: continue
        lore = _load_lore_module_dict(k)
        if lore.get("major_events"): 
            continue  # already has content
        lore.setdefault("major_events", [])
        for e in entries:
            title = e.get("title","")
            choice = e.get("choice","")
            text = e.get("text","")
            # simple one-liner
            first = (text or "").strip().split("\n",1)[0]
            if len(first) > 160: first = first[:157] + "..."
            lore["major_events"].append(f"{title} — Chose: {choice}. {first}")
        _write_lore_module_dict(k, lore)
